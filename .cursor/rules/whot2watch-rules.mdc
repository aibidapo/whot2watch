A. Contracts as Source of Truth

All API types are generated from GraphQL SDL / OpenAPI; no hand-rolled DTOs.

CI blocks merges if schema.graphql or openapi.yaml fail lint/validate.

ERD Mermaid must compile.

B. Naming & Glossary

Use canonical domain terms: Title, Availability, Provider, Region, Recommendation (Pick), List, Friend, GroupSession.

ESLint naming rules on; add Glossary.md; PRs that introduce synonyms must justify via ADR.

C. No TODO/FIXME

CI fails on TODO/FIXME in code or contracts (ESLint + Spectral rules). Use issues instead.

D. Ownership & Review Gates

CODEOWNERS required for /docs/*, /services/api, /apps/mobile, /apps/web, /docs/security/*.

Branch protection: at least one codeowner review + CI green.

E. Boundaries & Imports

No cross-layer imports (UI → data access). Enforce via dependency-cruiser / eslint-boundaries.

Only import from package public barrels (index.ts), not deep internals.

F. Security Defaults (OWASP)

Validation: zod on all inputs; reject unknown fields.

AuthZ: check ownership/role in service layer for every mutation/sensitive query.

GraphQL safety: depth ≤ 8, cost ≤ 1000, introspection off in prod, persisted/whitelist queries for public endpoints.

Headers: helmet, HSTS, CSP (no unsafe-eval), strict CORS allowlist.

Secrets: never in repo; gitleaks enforced.

Rate limits: /search, /picks, /auth.

G. Privacy & PII

Private Mode → no analytics/feedback writes.

No PII/secrets in logs; use redaction.

User export/delete flows must exist.

H. Testing Minimums

Unit + integration + contract tests; coverage ≥80%.

Negative tests: authZ denied, invalid inputs rejected, rate-limit 429s, GraphQL depth/cost rejections.

Mobile E2E for onboarding → picks → watch-now.

I. Duplication & Dead Code

jscpd threshold ≤ 5%; knip/ts-prune for unused exports — CI fails on findings.

J. Performance Budgets

Picks P50 <300ms, P95 <600ms (staging).

Search P50 <500ms. Regressions fail the PR unless explicitly waived.

K. Config & Flags

12-factor config (ENV). Feature flags for risky features (alerts/private-mode) with kill-switch.

L. Migrations Discipline

DB schema changes require migrations + rollback notes; data owner approval.

M. Commit & PR Hygiene

Conventional Commits; PR size kept reasonable; ADR required for pattern changes.

N. Accessibility & i18n (UI)

RN & Next: minimum a11y checks (labels, roles, contrast), i18n strings externalized.


###############################################################################################################

1. Error handling & logging; catch specific exceptions, add context (ids/params), never leak secrets.

2. Use approved libraries; deviations require an ADR.

3. Optimize lookups with sets/maps; precompute indexes for hot paths.

4. Prefer efficient algorithms; profile when in doubt.

5. Validate inputs at boundaries (zod/joi); reject unknowns.

6. Verify indices/ranges; fail fast with clear messages.

7. Keep code free of decorative symbols; UI copy only if UX-approved.

8. Keep modules focused; one responsibility per module.

9. Safe subprocesses only; avoid shell injection and untrusted input.

10. Handle exception types distinctly.

11. Cache repeatable external calls (TTL + eviction strategy).

12.  Contracts are source of truth; generate types from GraphQL/OpenAPI; ERD must compile.

13. Define schemas/enums; avoid magic values.

14. Consistent labeling (Provider/Region enums apply everywhere).

15. Parallelize independent tasks safely (queues/pools).

16.  Factor boilerplate into helpers/middleware.

17. Precompile repeat regex/patterns.

18. Use typed result objects; no ad-hoc any maps.

19. Distribute heavy loops to workers (threads/processes).

19. Lazy-load heavy/optional modules.

20. No broad catches.

21.  Enrich error logs with metadata; redact PII/secrets.

22. Validate required attributes once per workflow.

23.  Externalize configuration (ENV/JSON/YAML).

24.  Security defaults (OWASP Top 10 + ASVS): validation, authZ, headers, CORS, rate limits, GraphQL depth/cost/introspection-off in prod, secrets management.

25.  Isolate formatting/presentation logic.

26.  Inject dependencies (constructor or provider) for testability.

27.  Prune unused code/exports.

28.  No TODO/FIXME in code/contracts; open issues instead.

29.  Thorough type annotations; strict TS settings.

30.  One interpolation style across codebase.

31.  Document public interfaces (docstrings/API docs).

32.  Ownership & boundaries: CODEOWNERS enforced; dependency-cruiser rules; no deep imports.

33. Parse command output robustly; validate line formats.

34.  Surface encoding issues; don’t silently drop bytes.

35.  Comments: clear, concise, no buzzwords.

36.  Env management: Node via corepack/volta + pnpm; Python via venv/poetry.

37.  Testing minima: unit/integration/contract; coverage ≥80%; negative cases mandatory.

38.  Duplication & dead code: jscpd ≤5%; knip/ts-prune clean.

39.  Performance budgets: picks/search SLAs; CI fails on regressions unless waived.

40.  Privacy: Private Mode suppresses tracking; GDPR delete/export supported.

41.  Migrations: every schema change has an accompanying migration + rollback notes.

42.  Commit/PR hygiene: Conventional Commits; small PRs; ADR for pattern changes.

43.  A11y & i18n: basic accessibility checks; strings externalized.